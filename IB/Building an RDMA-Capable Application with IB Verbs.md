[TOC]

refer : http://www.hpcadvisorycouncil.com/pdf/building-an-rdma-capable-application-with-ib-verbs.pdf , 2010.08

# 目录
## 摘要

本文解释了应用之间使用IB verbs建立一个连接的必要步骤。RDMA连接管理器自动和简化设置流程。示例代码演示了如何使用verbs的send/receive语法建立连接和传输数据。

## 0 术语

1. CM：Connection Manager，连接管理

## 1 基础

如果您希望构建一个使用原生InfiniBand的应用，现在应该问问自己，如果使用InfiniBand的上层协议(ULPs)是否会更好，比如IP-over-IB/SDP或RDS，或者MPI。使用谓词库(libibverb，但我将它称为ibverb)编写程序并不难，但是为什么要重新发明轮子呢?
我选择ibverbs而不是MPI或任何可用的ULP的原因与IPoIB的性能优势有关，而且我的目标应用程序不适合MPI消息传递模型。

MPI-2的单向通信语义可能是有效的，但是由于与此讨论无关的原因，MPI无论如何都不是适合其作为开始的。

在查看使用ibverb编程的详细信息之前，我们应该介绍一些先决条件。我强烈推荐阅读InfiniBand贸易协会的介绍——特别是第一章和第四章(只有13页!)。我还假设您熟悉C语言编程，并且至少对套接字、MPI和网络有一定的了解。

我们的目标是连接两个应用程序，以便它们能够交换数据。使用可靠的、面向连接的套接字，这包括在服务器端设置一个监听套接字，并从客户端连接到它。一旦建立了连接，任何一方都可以调用send()和recv()来传输数据。这在ibverb中没有太大的变化，但是可以以更显式的方式完成任务。显著差异有:

1. 不局限于send和receive，读写远程内存（如RDMA）是很有用的。
2. 所有东西都是异步的，发送请求后，在接下来某个时间点会收到通知。
3. 在应用层，没有任何缓存。接收必须在发送之前发布。在请求完成之前，不能修改用于发送请求的内存。
4. 用于发送/接收操作的内存必须注册，这实际上“固定”了它，这样就不会被交换出去。

那么，在IB的世界中，我们如何在应用程序之间建立连接呢?如果你读过IBTA的介绍你就会知道,我们需要设置的关键部件是一对QP队列(由发送队列和接收队列组成)和完成队列。**连接的每一端都有一个发送-接收队列对和一个完成队列(但是请注意，在任何给定的应用程序中，单个发送或接收队列和完成队列之间的映射都可以是多对一的，即完成队列可以复用)** 。现在我将重点讨论可靠的、面向连接的服务(类似于TCP)。在以后的文章中，我将探讨数据报服务。

建立队列对并将它们彼此连接起来，以便在一边发布的操作在另一边执行，包括以下步骤:

1. 创建一个 protection domain(它关联队列对、完成队列、内存注册等)、一个完成队列和一个发送-接收队列对。
2. 确定队列对的地址。
3. 将地址通信到另一个节点(通过一些带外机制)
4. 将队列对转换为ready-to-receive (RTR)状态，然后转换为ready-to-send (RTS)状态
5. 适当时进行Post发送、接收等操作

第四步尤其令人不快，因此我们将使用事件驱动的连接管理器(CM)连接队列对、管理状态转换和处理错误。我们可以使用InfiniBand连接管理器，但是RDMA连接管理器(在librdmacm中，也称为连接管理器抽象)，使用更高级别的IP地址/端口号抽象，编写套接字程序的任何人都应该熟悉这个抽象。

这给了我们两个不同的程序，一个用于连接的被动方(响应方)，另一个用于主动方(启动方)。

被动方：

1. 创建一个事件通道，以便我们能够接收rdmacm事件，例如connection-request和connection-established通知
2. 绑定到一个地址
3. 创建一个监听器并返回端口/地址
4. 等待连接请求
5. 创建一个 protection domain、CQ和QP
6. 接受连接请求
7. 等待连接建立
8. Post operations as appropriate

主动方：

1. 创建一个事件通道，以便我们能够接收rdmacm事件，例如address-resolved、route-resolved和connection-established的通知
2. 创建连接标识符
3. 解析peer的地址，该地址将连接标识符绑定到本地RDMA设备
4. Create a protection domain, completion queue, and send-receive queue pair
5. Resolve the route to the peer
6. Connect
7. Wait for the connection to be established
8. Post operations as appropriate

可能值得指出的是，对于套接字，一旦建立了连接，双方都是对等的。使用连接需要我们在队列对上提交操作。接收操作(不出意料)被提交在接收队列上。在发送队列上，我们发布发送请求、RDMA读/写请求和原子操作请求。接下来的两部分将详细描述两个应用程序的构造:一个充当被动/服务器端，另一个充当主动/客户端。一旦连接，应用程序将交换一条简单的消息并断开连接。

如果还没有，下载并安装openfabric软件栈。您将需要它来构建下一节提供的示例代码。对于被动端/服务器和主动端/客户机，完整的示例代码都可以在网上找到。它远不是最优的，但是我将在以后的文章中讨论更多关于优化的内容。



## Passive/Server Side

